# Агрегатор IT мероприятий

Данный файл посвящен обзору технической стороны реализации проекта "Агрегатор IT мероприятий", реализуемого в рамках учебной практики 2020/21 года.

## Архитектура проекта

Для реализации проекта мы решили использовать микросервисную архитектуру. Причин немало: из-за независимости микросервисов удобнее разделять работу между несколькими разработчиками, легко проводить тестирование. Благодаря библиотеке `nameko` на `python` код таких сервисов получается простой и понятный, а возможностей, предоставляемых библиотекой, вполне достаточно, чтобы разрабатывать крупные проекты. Давайте более подробно рассмотрим какие сервисы мы разработали.

### Погрузчик данных

![draw](https://github.com/egorgorban/start-git/blob/master/draw.png)

В архитектуре можно выделить крупный модуль, связанный с подтягиванием данных из внешних источников, преобразованием их в удобную форму и сохранением в базе данных. Рассмотрим подробнее архитектуру этого модуля. Мы привлекаем данные с различных информационных источников с помощью микросервисов-краулеров (`it_events_crawler`, `it_world_crawler`, `softline_crawler`). Вследствие независимости этих краулеров, необходимо как-то инициализировать их работу и сохранять данные в некоторый промежуточный сервис-семафор. Этим занимается микросервис `raw_events_collector`. По таймеру (раз в сутки) он вызывает сбор "сырых", т.е. представленных в неокончательном виде, мероприятий с информационных ресурсов, получает патч событий и отправляет эти данные в сервис `primary_raw_events_handler`. Здесь происходит обработка сырых мероприятий: приведение их к единообразному виду и удаление повторяющихся мероприятий (с разных ресурсов могло поступить одно и то же мероприятие). Далее сервис посылает патч с мероприятиями в сервис `event_das` отвечающий за хранение и логику работы с мероприятиями. Для построения рекомендательной системы необходимо снабдить мероприятия тэгами, для чего `event_das` отсылает мероприятия сервису `event_theme_analyzer` и получает обратно мероприятия, размеченные тэгами. `event_theme_analyzer` также использует сервис `tag_das` для хранения существующих тэгов и подгрузки новых. Таким образом в результате работы данного модуля мы получаем актуальные унифицированные размеченные мероприятия, находящиеся в нашей базе данных.

### Взаимодействие с пользователями

![draw_2](https://github.com/egorgorban/start-git/blob/master/draw_2.png)

Дальше микросервисов становится только больше: нам еще необходимо реализовать авторизацию, систему оценивания (лайки, избранное), систему ранжирования и некоторые вспомогательные сервисы. Поэтому вполне разумно сделать еще и сервис, который будет медиатором для всех остальных, то есть который по мере необходимости будет посылать запросы к другим микросервисам. Это сервис API `gateway`. Здесь также происходит взаимодействие с front-частью: принимаются и посылаются http-запросы. По мере поступления того или иного запроса `gateway` и будет вызывать функции различных сервисов. Посмотрим, какие сервисы напрямую связаны с `gateway`.

Во-первых, это сервис аутентификации `auth`. Он предназначен для регистрации и входа пользователей. Во-вторых - реакционные сервисы: `likes` `favorites`. Методы этих сервисов вызываются, если пользователь поставил лайк на какое-то мероприятие или добавил его в избранное. В таком случае по цепочке вызывается вся система ранжирования, которую мы рассмотрим чуть позже. В-третьих это также один из сервисов системы ранжирования - `uis` - вызывается при получении анкеты, которая заполняется при регистрации или при изменении этой анкеты в дальнейшем. Его мы тоже рассмотрим позже. Наконец, это сервис `filter` - он предназначен для фильтрации всех мероприятий в соответствии с тэгами, выбранными пользователем и передачи списка id мероприятий в `gateway`. Этот сервис выстраивает мероприятия в соответствии с интересами пользователя (см. далее) и выкидывает те, которые не подошли по тэгам фильтрации. `gateway` также берёт информацию о самих мероприятиях, имея список их id, из сервиса `event_das` (единственный сервис из модуля "Погрузчик данных" с которым мы теперь взаимодействуем!)

Рассмотрим теперь систему ранжирования. Она состоит из трёх сервисов: `uis`, `ranking`, `top_das`. `uis` - сервис интересов пользователей, кроме того, что вызывается при получении анкеты пользователя, вызывается также при добавлении новых реакций (лайков, избранного и т.д.) Здесь мы рассматриваем любое получаемое событие как набор тэгов и метку о типе события. Логика сервиса такова: 1) определяем тип события: лайк - 1 отметка, избранное - 5 отметок, анкета - 50; 2) В зависимости от типа события мы изменяем вектор интересов пользователя, считая вес каждого тэга как вероятность того, что этот тэг находится в случайно выбранном "отмеченном" пользователем мероприятии; 3) сохраняем обновлённые данные и передаем событие с ними дальше по цепочке - в сервис ранжирования `ranking`. Сервис ранжирования также начинает работу при добавлении новых мероприятий в модуле погрузчике данных - тогда нужно обновить топы для всех пользователей. Логика сервиса заключается в том, что мы ранжируем мероприятия по степени близости их векторов к вектору интересов пользователя, полученному на предыдущем этапе. Далее отранжированный список передается в `top_das` - хранилище-обёртку над базой данных. Из этого хранилища берет информацию сервис фильтрации.

### Документация микросервисов

Мы использовали два типа обмена информацией между микросервисами: по `http` протоколу и через `rpc`, с помощью брокера сообщений `rabbitmq`. Передача по `http` предназначена для ручного тестирования или для связи с фронтом, тогда как взаимодействие сервисов между собой с помощью брокера - это способ передачи данных, когда проект уже развёрнут на хосте. Далее вы можете детально ознакомиться с документацией по каждому микросервису, в т.ч. с наличествующими `http` и `rpc` методами.

## Сервис аутентификации

Данный раздел содержит описание работы и информацию о развертке микросервиса, предназначенного для аутентификации пользователей.

Название: `auth`

Структура сервиса:

| Файл                 | Описание                                                   |
| -------------------- | ---------------------------------------------------------- |
| `auth.py`            | Код микросервиса                                           |
| `config.py`          | Конфигурационная информация для auth.py                    |
| `config.yml`         | Конфигурационный файл со строкой подключения к RabbitMQ    |
| `docker-compose.yml` | Изолированная развертка сервиса вместе с (RabbitMQ, Redis) |
| `run.sh`             | Файл для запуска сервиса из Docker контейнера              |
| `requirements.txt`   | Верхнеуровневые зависимости                                |
| `Dockerfile`         | Описание сборки контейнера сервиса                         |
| `README.md`          | Описание микросервиса                                      |

### API

#### RPC

Регистрация нового пользователя (логин пользователя должен быть уникальным):

```bat
n.rpc.auth.register(login, password)

Args: login (unique), password
Returns: True if user was registered and False otherwise
```

Вход в систему (получение JWT токена):

```bat
n.rpc.auth.login(login, password)

Args: login, password
Returns: JWT or False if user is not valid
```

Проверка JWT токена на валидность:

```bat
n.rpc.auth.check_jwt(jwt_token)

Args: JWT-token
Returns: user login or False if token is not valid
```

Получение списка логинов всех пользователей:

```bat
n.rpc.auth.get_all_logins()

Args: nothing
Returns: [login_1, ..., login_n]
```

### Запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ.

```bat
docker-compose up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run auth
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После того как откроется интерактивная Python среда, обратитесь к сервису одной из команд, представленных выше в разделе `rpc`.

#### _Запуск в контейнере_

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ и Redis в контейнерах.

## IT-Events Crawler

Данный раздел содержит описание работы и информацию о развертке микросервиса для сбора данных о мероприятиях с информационного ресурса [IT-Events](https://it-events.com/)

Название сервиса: `it_events_crawler`

Структура сервиса:

| Файл                   | Описание                                                                               |
| ---------------------- | -------------------------------------------------------------------------------------- |
| `it_events_crawler.py` | Код микросервиса, вместе с парсингом мероприятий с [IT-Events](https://it-events.com/) |
| `config.yml`           | Конфигурационный файл со строкой подключения к RabbitMQ                                |
| `run.sh`               | Файл для запуска краулера из Docker контейнера                                         |
| `requirements.txt`     | Верхнеуровневые зависимости                                                            |
| `requirements.lock`    | Все зависимости (`pip freeze`)                                                         |
| `Dockerfile`           | Описание сборки контейнера краулера                                                    |
| `docker-compose.yml`   | Изолированная развертка краулера вместе с RabbitMQ                                     |
| `README.md`            | Описание микросервиса                                                                  |
| `.rest`                | Тесты взаимодействия с HTTP эндпоинтами микросервиса                                   |
| `Procfile`             | Файл для развертки на heroku                                                           |

### API

#### RPC

Получение сырых мероприятий:

```bat
n.rpc.it_events_crawler.get_upcoming_events()

Args: nothing
Returns: [event_1, ..., event_n]
```

#### HTTP

Получение сырых мероприятий:

```rst
GET http://localhost:8000/events HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ:

```bat
sudo docker run -p 5672:5672 --hostname nameko-rabbitmq rabbitmq:3
```

Затем из папки микросервиса вызвать

```bat
nameko run it_events_crawler
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере из папки краулера вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Краулер запустится вместе с RabbitMQ в контейнерах.

## ITWorld Crawler

Данный раздел содержит описание работы и информацию о развертке микросервиса для сбора данных о мероприятиях с информационного ресурса [it-world](https://www.it-world.ru/events/)

Название сервиса: `it_world_crawler`

Структура сервиса:

| Файл                  | Описание                                                    |
| --------------------- | ----------------------------------------------------------- |
| `it_world_crawler.py` | Код микросервиса, вместе с парсингом мероприятий с it-world |
| `config.yml`          | Конфигурационный файл со строкой подключения к RabbitMQ     |
| `run.sh`              | Файл для запуска краулера из Docker контейнера              |
| `requirements.txt`    | Верхнеуровневые зависимости                                 |
| `requirements.lock`   | Все зависимости (`pip freeze`)                              |
| `Dockerfile`          | Описание сборки контейнера краулера                         |
| `docker-compose.yml`  | Изолированная развертка краулера вместе с RabbitMQ          |
| `.rest`               | Тесты взаимодействия с HTTP эндпоинтами микросервиса        |
| `README.md`           | Описание микросервиса                                       |

### API

#### RPC

Получение сырых мероприятий:

```bat
n.rpc.it_world_crawler.get_upcoming_events()

Args: nothing
Returns: [event_1, ..., event_n]
```

#### HTTP

Получение сырых мероприятий:

```rst
GET http://localhost:8000/events HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ:

```bat
sudo docker run -p 5672:5672 --hostname nameko-rabbitmq rabbitmq:3
```

Затем из папки микросервиса вызвать

```bat
nameko run it_world_crawler
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере из папки краулера вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Краулер запустится вместе с RabbitMQ в контейнерах.

## Softline Crawler

Данный раздел содержит описание работы и информацию о развертке микросервиса для сбора данных о мероприятиях с информационного ресурса [Softline](https://softline.ru/events?page=1)

Название сервиса: `softline_crawler`

Структура сервиса:

| Файл                  | Описание                                                    |
| --------------------- | ----------------------------------------------------------- |
| `softline_crawler.py` | Код микросервиса, вместе с парсингом мероприятий с Softline |
| `config.yml`          | Конфигурационный файл со строкой подключения к RabbitMQ     |
| `run.sh`              | Файл для запуска краулера из Docker контейнера              |
| `requirements.txt`    | Верхнеуровневые зависимости                                 |
| `requirements.lock`   | Все зависимости (`pip freeze`)                              |
| `Dockerfile`          | Описание сборки контейнера краулера                         |
| `docker-compose.yml`  | Изолированная развертка краулера вместе с RabbitMQ          |
| `.rest`               | Тесты взаимодействия с HTTP эндпоинтами микросервиса        |
| `README.md`           | Описание микросервиса                                       |

### API

#### RPC

Получение сырых мероприятий:

```bat
n.rpc.softline_crawler.get_upcoming_events()

Args: nothing
Returns: [event_1, ..., event_n]
```

#### HTTP

Получение сырых мероприятий:

```rst
GET http://localhost:8000/events HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ:

```bat
sudo docker run -p 5672:5672 --hostname nameko-rabbitmq rabbitmq:3
```

Затем из папки микросервиса вызвать

```bat
nameko run softline_crawler
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере из папки краулера вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Краулер запустится вместе с RabbitMQ в контейнерах.

## Хранилище мероприятий

Данный раздел содержит описание работы и информацию о развертке микросервиса-обертки для хранилища информации о мероприятиях

Название сервиса: `event_das`

Структура сервиса:

| Файл                       | Описание                                                          |
| -------------------------- | ----------------------------------------------------------------- |
| `event_das.py`             | Код микросервиса                                                  |
| `config.yml`               | Конфигурационный файл со строкой подключения к RabbitMQ и MongoDB |
| `run.sh`                   | Файл для запуска сервиса из Docker контейнера                     |
| `requirements.txt`         | Верхнеуровневые зависимости                                       |
| `requirements.lock`        | Все зависимости (`pip freeze`)                                    |
| `Dockerfile`               | Описание сборки контейнера сервиса                                |
| `docker-compose.yml`       | Изолированная развертка сервиса вместе с (RabbitMQ, MongoDB)      |
| `docker-compose.local.yml` | Развертка зависимостей для дебаггинга (RabbitMQ, MongoDB)         |
| `.rest`                    | Тесты взаимодействия с HTTP эндпоинтами микросервиса              |
| `README.md`                | Описание микросервиса                                             |

### API

#### RPC

Сохранить мероприятия:

```bat
n.rpc.event_das.save_events(events)

Args: list of events
Returns: nothing
```

Получить мероприятие по его ид:

```bat
n.rpc.event_das.get_event_by_id(event_id)

Args: event_id
Return: event as dictionary object
```

Получить мероприятия, отсортированные по дате:

```bat
n.rpc.event_das.get_events_by_date()

Args: nothing
Returns: list of actual events sorted by date
```

Получить тэги мероприятия по его ид:

```bat
n.rpc.event_das.get_tags_by_id(event_id)

Args: event_id
Returns: list of all tags related to the event
```

Получить список ид всех мероприятий с их тэгами в виде словаря:

```bat
n.rpc.event_das.get_event_tags()

Args: nothing
Returns: events like {'event_1_id': ['tag_1',...,'tag_n'], ..., 'event_m_id':['tag_1',...,'tag_k']}
```

#### HTTP

Сохранить мероприятия:

```rst
POST http://localhost:8000/events HTTP/1.1
Content-Type: application/json

[
  {
    "title": "Видео+Конференция 2020",
    "type": "Конференция",
    "isPaid": true,
    "isOnline": true,
    "location": "Москва, Россия",
    "startDate": "13.10.2020",
    "endDate": "14.10.2020",
    "description": "...",
    "meta": {
      "it_events_crawler": "18960"
    }
  }, ..., {}
]
```

Получить мероприятия, отсортированные по дате:

```rst
GET http://localhost:8000/allevents HTTP/1.1
```

Получить тэги мероприятия по его ид:

```rst
GET http://localhost:8000/events/<string:id>/tags HTTP/1.1
```

Получить список ид всех мероприятий с их тэгами в виде словаря:

```rst
GET http://localhost:8000/tags HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ и MongoDB. Для этого есть специальный `docker-compose.local.yml`. Чтобы запустить:

```bat
docker-compose --file docker-compose.local.yml up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run event_das
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ и MongoDB в контейнерах.

> Во всех случаях запуска вместе с MongoDB также разворачивается mongo-express - инструмент, с помощью которого можно просматривать и изменять содержимое подключенной базы (подключение в контейнерах сконфигурировано и производится автоматически). Сервис хостится локально на порту 8081.

## Хранилище тэгов

Данный раздел содержит описание работы и информацию о развертке микросервиса-обертки для хранилища тэгов для мероприятий.

Название сервиса: `tag_das`

Структура сервиса:

| Файл                       | Описание                                                          |
| -------------------------- | ----------------------------------------------------------------- |
| `tag_das.py`               | Код микросервиса                                                  |
| `config.yml`               | Конфигурационный файл со строкой подключения к RabbitMQ и MongoDB |
| `run.sh`                   | Файл для запуска сервиса из Docker контейнера                     |
| `requirements.txt`         | Верхнеуровневые зависимости                                       |
| `requirements.lock`        | Все зависимости (`pip freeze`)                                    |
| `Dockerfile`               | Описание сборки контейнера сервиса                                |
| `docker-compose.yml`       | Изолированная развертка сервиса вместе с (RabbitMQ, MongoDB)      |
| `docker-compose.local.yml` | Развертка зависимостей для дебаггинга (RabbitMQ, MongoDB)         |
| `.rest`                    | Тесты взаимодействия с HTTP эндпоинтами микросервиса              |
| `README.md`                | Описание микросервиса                                             |

### API

#### RPC

Получить тэги:

```bat
n.rpc.tag_das.get_tags()

Args: nothing
Returns: list of tags
```

Получить тэги c разбивкой по страницам:

```bat
n.rpc.tag_das.get_tags_by_page(page)

Args: page - number of the current page
Return: list of tags
```

Получить тэги по псевдониму:

```bat
n.rpc.tag_das.get_tags_by_alias(alias)

Args: alias (string)
Returns: list of tags
```

#### HTTP

Загрузить тэги с хабра:

```rst
GET http://localhost:8000/tags/upload HTTP/1.1
```

Получить тэги:

```rst
GET http://localhost:8000/tags HTTP/1.1
```

Получить тэги c разбивкой по страницам:

```rst
GET http://localhost:8000/tags/<int:page> HTTP/1.1
```

Получить тэги по псевдониму:

```rst
GET http://localhost:8000/tag/<string:alias> HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ и MongoDB. Для этого есть специальный `docker-compose.local.yml`. Чтобы запустить:

```bat
docker-compose --file docker-compose.local.yml up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run tag_das
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ и MongoDB в контейнерах.

> Во всех случаях запуска вместе с MongoDB также разворачивается mongo-express - инструмент, с помощью которого можно просматривать и изменять содержимое подключенной базы (подключение в контейнерах сконфигурировано и производится автоматически). Сервис хостится локально на порту 8081.

## Хранилище топов мероприятий

Данный раздел содержит описание работы и информацию о развертке микросервиса-обертки для хранилища топов мероприятий пользователей

Название сервиса: `top_das`

Структура сервиса:

| Файл                 | Описание                                                        |
| -------------------- | --------------------------------------------------------------- |
| `top_das.py`         | Код микросервиса                                                |
| `config.yml`         | Конфигурационный файл со строкой подключения к RabbitMQ и Redis |
| `run.sh`             | Файл для запуска сервиса из Docker контейнера                   |
| `requirements.txt`   | Верхнеуровневые зависимости                                     |
| `Dockerfile`         | Описание сборки контейнера сервиса                              |
| `docker-compose.yml` | Изолированная развертка сервиса вместе с (RabbitMQ, Redis)      |
| `README.md`          | Описание микросервиса                                           |

### API

#### RPC

Обновить топ мероприятий пользователя:

```bat
n.rpc.top_das.update_top(user_id, new_top)

Args:
    user_id,
    new_top - list of IDs [id1, id2, ..] of top events
Returns nothing
```

Получить топ мероприятий пользователя:

```bat
n.rpc.top_das.get_top(user_id)

Args: user_id
Return: list of IDs [id1, id2, ..] of top events
```

Удалить мероприятия (например, прошедшие):

```bat
n.rpc.top_das.delete_events(event_ids)

Args: event_ids - list of ids of events should be deleted
Returns nothing
```

#### HTTP

Обновить топ мероприятий пользователя:

```rst
POST http://localhost:8000/update HTTP/1.1
Сontent-Type: application/json

{
    "user": <user_id>,
    "top": ['event_1_id', ..., 'event_n_id']
}
```

Получить топ мероприятий пользователя:

```rst
GET http://localhost:8000/top HTTP/1.1
```

Удалить мероприятия (например, прошедшие):

```rst
DELETE http://localhost:8000/delete HTTP/1.1
Сontent-Type: application/json

{
    [id_1, id_2, ..., id_n]
}
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ и Redis.

```bat
docker-compose up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run top_das
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ и Redis в контейнерах.

## Анализ тематики мероприятия

Данный раздел содержит описание работы и информацию о развертке микросервиса предназначенного для вычленения ключевых слов из заданного набора (тэгов) по текстовому описанию мероприятия.

Название: `event_theme_analyzer`

Структура сервиса:

| Файл                       | Описание                                                |
| -------------------------- | ------------------------------------------------------- |
| `event_theme_analyzer.py`  | Код микросервиса                                        |
| `config.yml`               | Конфигурационный файл со строкой подключения к RabbitMQ |
| `run.sh`                   | Файл для запуска сервиса из Docker контейнера           |
| `requirements.txt`         | Верхнеуровневые зависимости                             |
| `requirements.lock`        | Все зависимости (`pip freeze`)                          |
| `Dockerfile`               | Описание сборки контейнера сервиса                      |
| `docker-compose.yml`       | Изолированная развертка сервиса вместе с (RabbitMQ)     |
| `docker-compose.local.yml` | Развертка зависимостей для дебаггинга (RabbitMQ)        |
| `.rest`                    | Тесты взаимодействия с HTTP эндпоинтами микросервиса    |
| `README.md`                | Описание микросервиса                                   |

### API

#### RPC

Проанализировать мероприятие и добавить к нему тэги:

```bat
n.rpc.event_theme_analyzer.analyze_events(events)

Args: events = [event_1, ..., event_m]
Returns: list of the events with 'tags' field added
```

#### HTTP

Новая анкета или обновление данных по анкете:

```rst
POST http://localhost:8000/analyze HTTP/1.1
Content-Type: application/json

'... a description of the event ...'
```

Препроцессинг мероприятия:

```rst
GET http://localhost:8000/preprocess HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ. Для этого есть специальный `docker-compose.local.yml`. Чтобы запустить:

```bat
docker-compose --file docker-compose.local.yml up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run event_theme_analyzer
```

После чего можно проверить работоспособность сервиса через `.rest` файл (с расширением для VSCode/PyCharm), через Postman. Проверка таким образом производится по `http`.

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ в контейнере.

## Сервис фильтрации мероприятий

Данный раздел содержит описание работы и информацию о развертке микросервиса, предназначенного для фильтрации мероприятий по тэгам.

Название: `filter`

Структура сервиса:

| Файл               | Описание                                                |
| ------------------ | ------------------------------------------------------- |
| `filter.py`        | Код микросервиса                                        |
| `config.yml`       | Конфигурационный файл со строкой подключения к RabbitMQ |
| `run.sh`           | Файл для запуска сервиса из Docker контейнера           |
| `requirements.txt` | Верхнеуровневые зависимости                             |
| `Dockerfile`       | Описание сборки контейнера сервиса                      |
| `README.md`        | Описание микросервиса                                   |

### API

#### RPC

ФИльтрация мероприятий по тэгам:

```bat
n.rpc.filter.get_events(user_id, tags)

Args:
    user_id,
    tags : list of tags like ['forums', 'online', ...]
Returns:
    [event_1, event_2, ..., event_m]
```

### Запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ.

```bat
docker run -p 5672:5672 --hostname nameko-rabbitmq rabbitmq:3
```

Затем из папки микросервиса вызвать

```bat
nameko run filter
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда и обратитесь к сервису одной из команд, представленных выше в разделе `rpc`.

## API - медиатор для микросервисов

Данный раздел содержит описание работы и информацию о развертке микросервиса API.

Название сервиса: `gateway`

Общедоступный IP-адрес: `20.52.2.24`

Структура сервиса:

| Файл                 | Описание                                                |
| -------------------- | ------------------------------------------------------- |
| `gateway.py`         | Код микросервиса                                        |
| `config.yml`         | Конфигурационный файл со строкой подключения к RabbitMQ |
| `run.sh`             | Файл для запуска сервиса из Docker контейнера           |
| `requirements.txt`   | Верхнеуровневые зависимости                             |
| `Dockerfile`         | Описание сборки контейнера сервиса                      |
| `docker-compose.yml` | Изолированная развертка сервиса вместе с RabbitMQ       |
| `README.md`          | Описание микросервиса                                   |

### API

#### HTTP

Регистрация пользователей:

```rst
POST http://localhost:8000/register HTTP/1.1
Content-Type: application/json

{
    "login": <login>,
    "password": <password>
}

Response (Сообщение об успехе, либо ошибка):
Status: 201 - успех, 400 - ошибка регистрации
Content-Type: application/json

{
    "message": <msg>
}
```

Вход:

```rst
POST http://localhost:8000/login HTTP/1.1
Content-Type: application/json

{
    "login": <login>,
    "password": <password>
}

Response (Correct credentials):
Status: 202 - успех
Content-Type: application/json

{
    "token": <token>
}

Response (Wrong credentials):
Status: 400 - неверный логин или пароль
Content-Type: application/json

{
    "message": <msg>
}
```

**В теле всех остальных запросов должен присутствовать JWT токен, если это зарегистрированный пользователь.**

Получение ленты событий:

```rst
POST http://localhost:8000/feed HTTP/1.1
Content-Type: application/json

{
    "token": <token>, (Может быть не указан, если пользователь не авторизован)
    "tags": [..] - Теги для фильтрации (могут быть не указаны)
}

Response:
Status: 200 - успех
Content-Type: application/json

[
    {
        "_id": <event_id>,
        "title": <title>,
        "location": <location>,
        "startDate": <startDate>,
        "endDate": <endDate>,
        "description": <description>,
        "meta": <meta>,
        "tags": [..] - list
    },
    {
        "_id": <event_id>,
        "title": <title>,
        "location": <location>,
        "startDate": <startDate>,
        "endDate": <endDate>,
        "description": <description>,
        "meta": <meta>,
        "tags": [..] - list
    }
    ...
]

Response (При неверном токене):
Status: 403 - неверный токен
Content-Type: application/json

{
    "message": <msg>
}
```

Получение определенного события:

```rst
GET http://localhost:8000/feed/<string:event_id>?token=<token> HTTP/1.1

Query parameters:
{
    "token": <token> (Может быть не указан, если пользователь не авторизован)
}

Response (событие):
Status: 200
Content-Type: application/json

{
    "_id": <event_id>,
    "title": <title>,
    "location": <location>,
    "startDate": <startDate>,
    "endDate": <endDate>,
    "description": <description>,
    "meta": <meta>,
    "tags": [..] - list
}

Response (ошибка):
Status: 403 - неверный токен
Content-Type: application/json

{
    "message": <msg>
}
```

Получение интересов пользователя:

```rst
GET http://localhost:8000/profile/interests?token=<token> HTTP/1.1

Query parameters:
{
    "token": <token>
}

Response:
Status: 200 - успех
Content-Type: application/json

{
    "interests": ['tag1', 'tag2', ...],
    "ind": [True, False, False, ...]
}

Response (Не передан токен, либо он неверный):
Status: 401 - пользователь не авторизован (токен не передан), 403 - неверный токен
Content-Type: application/json

{
    "message": <msg>
}
```

Добавление новой анкеты интересов:

```rst
POST http://localhost:8000/profile/interests HTTP/1.1
Content-Type: application/json

{
    "token": <token>,
    "interests": ['tag1', 'tag2', ...],
    "ind": [True, False, False, ...]
}

Response (Сообщение об успешном добавлении, либо ошибка):
Status: 200 - успех, 401 - пользователь не авторизован (токен не передан), 403 - неверный токен
Content-Type: application/json

{
    "message": <msg>
}
```

Изменение интересов:

```rst
PUT http://localhost:8000/profile/interests HTTP/1.1
Content-Type: application/json

{
    "token": <token>,
    "interests": ['tag1', 'tag2', ...],
    "ind": [True, False, False, ...]
}

Response (Сообщение об успешном изменении, либо ошибка):
Status: 200 - успех, 401 - пользователь не авторизован (токен не передан), 403 - неверный токен
Content-Type: application/json

{
    "message": <msg>
}
```

**Далее описаны запросы для лайков, для добавление в избранное заменить like на favorite в адресе.**

Реакционное событие (добавление лайка):

```rst
POST http://localhost:8000/reaction/like HTTP/1.1
Content-Type: application/json

{
    "token": <token>,
    "event_id": <event_id>
}

Response (Сообщение об успехе, либо ошибка):
Status: 200 - успех, 401 - пользователь не авторизован (токен не передан), 403 - неверный токен
Content-Type: application/json

{
    "message": <msg>
}
```

Реакционное событие (получение всех лайков/наличие лайка у мероприятия):

```rst
GET http://localhost:8000/reaction/like?token=<token>&event_id=<event_id> HTTP/1.1
Content-Type: application/json

Query parameters:
{
    "token": <token>,
    "event_id": <event_id> - Указывается, если нужно узнать наличие лайка у конкретного мероприятия
}

Response (успех, запрос на все лайки):
Status: 200
Content-Type: application/json

[
    event_id1, - id, лайкнутых всех событий
    event_id2,
    ...
]

Response (успех, конкретное мерориятие):
Status: 200
Content-Type: application/json

{
    "value": (true or false)
}

Response (ошибка):
Status: 401 - пользователь не авторизован (токен не передан), 403 - неверный токен
Content-Type: application/json

{
    "message": <msg>
}
```

Реакционное событие (удаление лайка):

```rst
DELETE http://localhost:8000/reaction/like HTTP/1.1
Content-Type: application/json

{
    "token": <token>,
    "event_id": <event_id>
}

Response (Сообщение об успехе, либо ошибка):
Status: 200 - успех, 401 - пользователь не авторизован (токен не передан), 403 - неверный токен
Content-Type: application/json

{
    "message": <msg>
}
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ.

```bat
docker-compose up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run gateway
```

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

## Сервис логгирования

Данный раздел содержит описание работы и информацию о развертке микросервиса предназначенного для сохранения логов работы всех микросервисов.

Название: `logger`

Структура сервиса:

| Файл                 | Описание                                                          |
| -------------------- | ----------------------------------------------------------------- |
| `logger.py`          | Код микросервиса                                                  |
| `config.yml`         | Конфигурационный файл со строкой подключения к RabbitMQ и MongoDB |
| `run.sh`             | Файл для запуска сервиса из Docker контейнера                     |
| `requirements.txt`   | Верхнеуровневые зависимости                                       |
| `Dockerfile`         | Описание сборки контейнера сервиса                                |
| `docker-compose.yml` | Изолированная развертка сервиса вместе с (RabbitMQ, MongoDB)      |
| `README.md`          | Описание микросервиса                                             |

### API

#### RPC

Для добавления логов в микрос нужно импортировать `RpcProxy`, если его еще нет:

```pyt
from nameko.rpc import RpcProxy
```

В поле класса микросервиса добавить:

```pyt
logger_rpc = RpcProxy('logger')
```

После этого нужных местах вызывать соответствующий метод:

```pyt
self.logger_rpc.log(<имя микросервиса>, <имя текущего метода>, <аргументы метода>, <статус>, <описание лога>)
```

- Имя микросервиса: `self.name`
- Имя текущего метода: `self.<method>._name__`
- Если метод не имеет аргументов - `None`, если аргумент один - сам аргумент, если аргументов несколько - список этих аргументов. Все аргументы должны быть _**json сериализуемы!**_
- Статус: `Info` - информационное сообщение, `Error` - ошибка.
- Описание лога: строка с описанием произошедшего.

#### HTTP

Для получения логов можно использовать один из двух методов:

- Полная версия логов с аргументами:
  
```rst
GET http://localhost:8013/full_logs HTTP/1.1
```

- Урезанная версия логов без аргументов:
  
```rst
GET http://localhost:8013/short_logs HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ и MongoDB. 

```bat
docker-compose up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run logger
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ в контейнере.

> Во всех случаях запуска вместе с MongoDB также разворачивается mongo-express - инструмент, с помощью которого можно просматривать и изменять содержимое подключенной базы (подключение в контейнерах сконфигурировано и производится автоматически). Сервис хостится локально на порту 8081.

## Первичный обработчик сырых мероприятий

Данный раздел содержит описание работы и информацию о развертке микросервиса, предназначенного для получения патча сырых мероприятий, удаления дублей и перенаправления полученных таким образом мероприятий в сервис хранилище мероприятий.

Название: `primary_raw_events_handler`

Структура сервиса:

| Файл               | Описание                                                |
| ------------------ | ------------------------------------------------------- |
| `preh.py`          | Код микросервиса                                        |
| `config.yml`       | Конфигурационный файл со строкой подключения к RabbitMQ |
| `run.sh`           | Файл для запуска сервиса из Docker контейнера           |
| `requirements.txt` | Верхнеуровневые зависимости                             |
| `Dockerfile`       | Описание сборки контейнера сервиса                      |
| `.rest`            | Тесты взаимодействия с HTTP эндпоинтами микросервиса    |
| `README.md`        | Описание микросервиса                                   |

### API

#### RPC

Получение уникальных событий:

```bat
n.rpc.primary_raw_events_handler.receive_events()

Args: a batch with events
Returns: a batch with unique events
```

#### HTTP

Получение уникальных событий:

```rst
POST http://localhost:8000/process HTTP/1.1
Content-Type: application/json

[event_1, event_2, ..., event_n]
```

### Запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ.

```bat
docker run -p 5672:5672 --hostname nameko-rabbitmq rabbitmq:3
```

Затем из папки микросервиса вызвать

```bat
nameko run primary_raw_events_handler
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда и обратитесь к сервису одной из команд, представленных выше в разделе `rpc`.

## Сервис ранжирования мероприятий

Данный раздел содержит описание работы и информацию о развертке микросервиса, предназначенного для ранжирования мероприятий для пользователя в соответствии с его интересами.

Название сервиса: `ranking_service`

Структура сервиса:

| Файл                 | Описание                                                     |
| -------------------- | ------------------------------------------------------------ |
| `ranking_service.py` | Код микросервиса                                             |
| `config.yml`         | Кофигурационный файл со строкой подключения к RabbitMQ       |
| `run.sh`             | Файл для запуска сервиса из Docker контейнера                |
| `requirements.txt`   | Верхнеуровневые зависимости                                  |
| `Dockerfile`         | Описание сборки контейнера сервиса                           |
| `docker-compose.yml` | Изолированная развертка сервиса вместе с (RabbitMQ, MongoDB) |
| `README.md`          | Описание микросервиса                                        |

### API

#### RPC

Составить или изменить список мероприятий, интересных пользователю

```bat
n.rpc.ranking_service.change_top_user([user_id, user_tags])

Args:
    list of two values -
        user_id
        user_tags - dict like {'tag_1': w_1, ..., 'tag_m': w_m}
Returns nothing
Sendind  user's top to `top_das`
```

Составить или изменить список мероприятий, интересных пользователю - для всех пользователей

```bat
n.rpc.ranking_service.change_top_all(plug)

Args:
    plug - can be anything (is used only due to event_handler's syntaxis)
Returns nothing
Call for ranking_service.change_top_user for all user in db
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ.

```bat
docker-compose up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run ranking_service
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

## Сервис лайков

Данный раздел содержит описание работы и информацию о развертке микросервиса, предназначенного для хранения информации о лайках, поставленных пользователем и отправляющего информацию о новых лайках в сервис интересов пользователей.

Название: `likes`

Структура сервиса:

| Файл                 | Описание                                                          |
| -------------------- | ----------------------------------------------------------------- |
| `likes.py`           | Код микросервиса                                                  |
| `config.yml`         | Конфигурационный файл со строкой подключения к RabbitMQ и MongoDB |
| `run.sh`             | Файл для запуска сервиса из Docker контейнера                     |
| `requirements.txt`   | Верхнеуровневые зависимости                                       |
| `Dockerfile`         | Описание сборки контейнера сервиса                                |
| `docker-compose.yml` | Изолированная развертка сервиса вместе с (RabbitMQ, MongoDB)      |
| `README.md`          | Описание микросервиса                                             |

### API

#### RPC

Новый лайк:

```bat
n.rpc.likes.new_like(like_data)

Args: like_data = [user_id, event_id]
Returns: nothing
Dispatch to the `uis`: [user_id, event_id]
```

Отмена лайка:

```bat
n.rpc.likes.cancel_like(like_data)

Args: like_data = [user_id, event_id]
Returns: nothing
Dispatch to the `uis`: [user_id, event_id]
```

Получить список ид мероприятий, которые понравились пользователю:

```bat
n.rpc.likes.get_likes_by_id(user_id)

Args: user_id
Returns: [event_1_id, ..., event_n_id]
```

Узнать, понравилось ли пользователю данное мероприятие:

```bat
n.rpc.likes.is_event_liked(user_id, event_id)

Args: user_id, event_id
Returns: True is event is liked, False otherwise
```

#### HTTP

Новый лайк

```rst
POST http://localhost:8000/new_like HTTP/1.1
Content-Type: application/json

[user_id, event_id]
```

Отмена лайка:

```rst
POST http://localhost:8000/cancel_like HTTP/1.1
Content-Type: application/json

[user_id, event_id]
```

Получить список ид мероприятий, которые понравились пользователю:

```rst
GET http://localhost:8000/get_likes/<id> HTTP/1.1
```

Узнать, понравилось ли пользователю данное мероприятие:

```rst
GET http://localhost:8000/is_liked/<user_id>/<event_id> HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ и MongoDB.

```bat
docker-compose up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run likes
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`.

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ и MongoDB в контейнерах.

> Во всех случаях запуска вместе с MongoDB также разворачивается mongo-express - инструмент, с помощью которого можно просматривать и изменять содержимое подключенной базы (подключение в контейнерах сконфигурировано и производится автоматически). Сервис хостится локально на порту 8081.

## Сервис избранных мероприятий

Данный раздел содержит описание работы и информацию о развертке микросервиса, предназначенного для хранения информации о мероприятиях, добавленных пользователем в избранное и отправляющего информацию о добавлениях в сервис интересов пользователей.

Название: `favorites`

Структура сервиса:

| Файл                 | Описание                                                          |
| -------------------- | ----------------------------------------------------------------- |
| `favorites.py`       | Код микросервиса                                                  |
| `config.yml`         | Конфигурационный файл со строкой подключения к RabbitMQ и MongoDB |
| `run.sh`             | Файл для запуска сервиса из Docker контейнера                     |
| `requirements.txt`   | Верхнеуровневые зависимости                                       |
| `Dockerfile`         | Описание сборки контейнера сервиса                                |
| `docker-compose.yml` | Изолированная развертка сервиса вместе с (RabbitMQ, MongoDB)      |
| `README.md`          | Описание микросервиса                                             |

### API

#### RPC

Добавление в избранное:

```bat
n.rpc.favorites.new_fav(fav_data)

Args: fav_data = [user_id, event_id]
Returns: nothing
Dispatch to the `uis`: [user_id, event_id]
```

Исключение из избранного:

```bat
n.rpc.favorites.cancel_fav(fav_data)

Args: fav_data = [user_id, event_id]
Returns: nothing
Dispatch to the `uis`: [user_id, event_id]
```

Получить список ид мероприятий, которые пользователь добавил в избранное:

```bat
n.rpc.favorites.get_favs_by_id(user_id)

Args: user_id
Returns: [event_1_id, ..., event_n_id]
```

Узнать, добавил ли пользователь данное мероприятие в избранное:

```bat
n.rpc.favorites.is_event_faved(user_id, event_id)

Args: user_id, event_id
Returns: True is event is faved, False otherwise
```

#### HTTP

Добавление в избранное:

```rst
POST http://localhost:8000/new_fav HTTP/1.1
Content-Type: application/json

[user_id, event_id]
```

Исключение из избранного:

```rst
POST http://localhost:8000/cancel_fav HTTP/1.1
Content-Type: application/json

[user_id, event_id]
```

Получить список ид мероприятий, которые пользователь добавил в избранное:

```rst
GET http://localhost:8000/get_favs/<id> HTTP/1.1
```

Узнать, добавил ли пользователь данное мероприятие в избранное:

```rst
GET http://localhost:8000/is_faved/<user_id>/<event_id> HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ и MongoDB.

```bat
docker-compose up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run favorites
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда. Обратитесь к сервису одной из команд, представленных выше в разделе `rpc`.

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ и MongoDB в контейнерах.

> Во всех случаях запуска вместе с MongoDB также разворачивается mongo-express - инструмент, с помощью которого можно просматривать и изменять содержимое подключенной базы (подключение в контейнерах сконфигурировано и производится автоматически). Сервис хостится локально на порту 8081.

## Сборщик сырых мероприятий

Данный раздел содержит описание работы и информацию о развертке микросервиса, предназначенного для получения мероприятий посредством запуска краулеров и перенаправления полученных таким образом мероприятий в сервис первичной обработки сырых мероприятий.

Название: `raw_events_collector`

Структура сервиса:

| Файл               | Описание                                                |
| ------------------ | ------------------------------------------------------- |
| `rec.py`           | Код микросервиса                                        |
| `config.py`        | Файл с кофигурационной информацией для rec.py           |
| `config.yml`       | Конфигурационный файл со строкой подключения к RabbitMQ |
| `run.sh`           | Файл для запуска краулера из Docker контейнера          |
| `requirements.txt` | Верхнеуровневые зависимости                             |
| `Dockerfile`       | Описание сборки контейнера сервиса                      |
| `README.md`        | Описание микросервиса                                   |

### API

#### RPC

Получение новых событий:

```bat
n.rpc.raw_events_collector.update()

Args: nothing
Returns: a batch with all events
```

#### HTTP

Получение новых событий:

```bat
GET http://localhost:8000/events HTTP/1.1
```

### Запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ.

```bat
docker run -p 5672:5672 --hostname nameko-rabbitmq rabbitmq:3
```

Затем из папки микросервиса вызвать

```bat
nameko run rec
```

Сервис запустится самостоятельно, и с помощью декоратора `@timer` будет обновлять события каждые сутки

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда и обратитесь к сервису одной из команд, представленных выше в разделе `rpc`.

#### Запуск в контейнере

_Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ в контейнере._

### Настройка и добавление новых краулеров

Файл `config.py` содержит список всех краулеров. Там же настраивается интервал обновления в секундах через `TIMER` и время обновления `TIME`. Для добавления новых добавить 2 строчки:

```pyt
crawler_name_rpc = RpcProxy('crawler_name')
```

в раздел `Crawlers` и

```pyt
get_res.append(self.crawler_name_rpc.get_upcoming_events.call_async())
```

в метод `update()`.

## Сервис интересов пользователя

Данный раздел содержит описание работы и информацию о развертке микросервиса, предназначенного для хранения информации об интересах пользователя и отправляющего данные об изменениях интересов сервису ранжирования.

Название: `uis`

Структура сервиса:

| Файл                 | Описание                                                          |
| -------------------- | ----------------------------------------------------------------- |
| `uis.py`             | Код микросервиса                                                  |
| `config.yml`         | Конфигурационный файл со строкой подключения к RabbitMQ и MongoDB |
| `run.sh`             | Файл для запуска сервиса из Docker контейнера                     |
| `requirements.txt`   | Верхнеуровневые зависимости                                       |
| `Dockerfile`         | Описание сборки контейнера сервиса                                |
| `docker-compose.yml` | Изолированная развертка сервиса вместе с (RabbitMQ, MongoDB)      |
| `README.md`          | Описание микросервиса                                             |

### API

#### RPC

Новая анкета или обновление данных по анкете:

```bat
n.rpc.uis.create_new_q(<questionnaire>)

Args: questionnaire = [user_id, [tag_1, tag_2, ..., tag_m]]
Returns: nothing
Dispatch to the `ranking`: [user_id, {'<tag_name_1>': w_1, ..., '<tag_name_n>': w_n}]
```

Добавление, отмена лайка:

```bat
n.rpc.uis.add_like(like_data)
n.rpc.uis.cancel_like(like_data)

Args: like_data = [user_id, event_id]
Returns: nothing
Dispatch to the `ranking`: [user_id, {'<tag_name_1>': w_1, ..., '<tag_name_n>': w_n}]
```

Добавление в избранное, удаление из избранного:

```bat
n.rpc.uis.add_fav(fav_data)
n.rpc.uis.cancel_fav(fav_data)

Args: fav_data = [user_id, event_id]
Returns: nothing
Dispatch to the `ranking`: [user_id, {'<tag_name_1>': w_1, ..., '<tag_name_n>': w_n}]
```

Получить интересы пользователей по id:

```bat
n.rpc.uis.get_weights_by_id(user_id)

Args: user_id - id of the user
Returns: {'<tag_name_1>': w_1, ..., '<tag_name_n>': w_n}
```

Получить булевский список:

```bat
n.rpc.uis.get_bool_list(user_id)

Args: user_id - id of the user
Returns: [True, False, False, ...] if user is presented in db and None otherwise
```

Сохранить булевский список:

```bat
n.rpc.uis.save_bool_list(user_id, bool_list)

Args: 
    user_id - id of the user,
    bool_list - list like [True, False, False, ...]
Returns: nothing
```

#### HTTP

Новая анкета или обновление данных по анкете:

```rst
POST http://localhost:8000/newq HTTP/1.1
Content-Type: application/json

[user_id, [
    'tag_1', 'tag_2', ..., 'tag_m'
]]
```

Добавление лайка:

```rst
POST http://localhost:8000/got_like HTTP/1.1
Content-Type: application/json

[user_id, event_id]
```

Отмена лайка:

```rst
POST http://localhost:8000/cancel_like HTTP/1.1
Content-Type: application/json

[user_id, event_id]
```

Добавление в избранное:

```rst
POST http://localhost:8000/got_fav HTTP/1.1
Content-Type: application/json

[user_id, event_id]
```

Удаление из избранного:

```rst
POST http://localhost:8000/cancel_fav HTTP/1.1
Content-Type: application/json

[user_id, event_id]
```

Получить интересы пользователей по id:

```rst
GET http://localhost:8000/get_weights/<id> HTTP/1.1
```

### Развертывание и запуск

#### Локальный запуск

Для локального запуска микросервиса требуется запустить контейнер с RabbitMQ и MongoDB.

```bat
docker-compose up -d
```

Затем из папки микросервиса вызвать

```bat
nameko run uis
```

Для проверки `rpc` запустите в командной строке:

```bat
nameko shell
```

После чего откроется интерактивная Python среда и обратитесь к сервису одной из команд, представленных выше в разделе `rpc`.

#### Запуск в контейнере

Чтобы запустить микросервис в контейнере вызовите команду:

```bat
docker-compose up
```

> если вы не хотите просмотривать логи, добавьте флаг `-d` в конце

Микросервис запустится вместе с RabbitMQ и MongoDB в контейнерах.

> Во всех случаях запуска вместе с MongoDB также разворачивается mongo-express - инструмент, с помощью которого можно просматривать и изменять содержимое подключенной базы (подключение в контейнерах сконфигурировано и производится автоматически). Сервис хостится локально на порту 8081.
