# Агрегатор IT мероприятий

Данный файл посвящен обзору технической стороны реализации проекта "Агрегатор IT мероприятий", реализуемого в рамках учебной практики 2020/21 года.

## Архитектура проекта

Для реализации проекта мы решили использовать микросервисную архитектуру. Причин немало: из-за независимости микросервисов удобнее разделять работу между несколькими разработчиками, легко проводить тестирование. Благодаря библиотеке `nameko` на `python` код таких сервисов получается простой и понятный, а возможностей, предоставляемых библиотекой, вполне достаточно, чтобы разрабатывать крупные проекты. Давайте более подробно рассмотрим какие сервисы мы разработали.

### Погрузчик данных

В архитектуре можно выделить крупный модуль, связанный с подтягиванием данных из внешних источников, преобразованием их в удобную форму и сохранением в базе данных. Рассмотрим подробнее архитектуру этого модуля. Мы привлекаем данные с различных информационных источников с помощью микросервисов-краулеров (`it_events_crawler`, `it_world_crawler`, `softline_crawler`). Вследствие независимости этих краулеров, необходимо как-то инициализировать их работу и сохранять данные в некоторый промежуточный сервис-семафор. Этим занимается микросервис `raw_events_collector`. По таймеру (раз в сутки) он вызывает сбор "сырых", т.е. представленных в неокончательном виде, мероприятий с информационных ресурсов, получает патч событий и отправляет эти данные в сервис `primary_raw_events_handler`. Здесь происходит обработка сырых мероприятий: приведение их к единообразному виду и удаление повторяющихся мероприятий (с разных ресурсов могло поступить одно и то же мероприятие). Далее сервис посылает патч с мероприятиями в сервис `event_das` отвечающий за хранение и логику работы с мероприятиями. Для построения рекомендательной системы необходимо снабдить мероприятия тэгами, для чего `event_das` отсылает мероприятия сервису `event_theme_analyzer` и получает обратно мероприятия, размеченные тэгами. `event_theme_analyzer` также использует сервис `tag_das` для хранения существующих тэгов и подгрузки новых. Таким образом в результате работы данного модуля мы получаем актуальные унифицированные размеченные мероприятия, находящиеся в нашей базе данных.

### Взаимодействие с пользователями

Дальше микросервисов становится только больше: нам еще необходимо реализовать авторизацию, систему оценивания (лайки, избранное), систему ранжирования и некоторые вспомогательные сервисы. Поэтому вполне разумно сделать еще и сервис, который будет медиатором для всех остальных, то есть который по мере необходимости будет посылать запросы к другим микросервисам. Это сервис API `gateway`. Здесь также происходит взаимодействие с front-частью: принимаются и посылаются http-запросы. По мере поступления того или иного запроса `gateway` и будет вызывать функции различных сервисов. Посмотрим, какие сервисы напрямую связаны с `gateway`.

Во-первых, это сервис аутентификации `auth`. Он предназначен для регистрации и входа пользователей. Во-вторых - реакционные сервисы: `likes` `favorites`. Методы этих сервисов вызываются, если пользователь поставил лайк на какое-то мероприятие или добавил его в избранное. В таком случае по цепочке вызывается вся система ранжирования, которую мы рассмотрим чуть позже. В-третьих это также один из сервисов системы ранжирования - `uis` - вызывается при получении анкеты, которая заполняется при регистрации или при изменении этой анкеты в дальнейшем. Его мы тоже рассмотрим позже. Наконец, это сервис `filter` - он предназначен для фильтрации всех мероприятий в соответствии с тэгами, выбранными пользователем и передачи списка id мероприятий в `gateway`. Этот сервис выстраивает мероприятия в соответствии с интересами пользователя (см. далее) и выкидывает те, которые не подошли по тэгам фильтрации. `gateway` также берёт информацию о самих мероприятиях, имея список их id, из сервиса `event_das` (единственный сервис из модуля "Погрузчик данных" с которым мы теперь взаимодействуем!)

Рассмотрим теперь систему ранжирования. Она состоит из трёх сервисов: `uis`, `ranking`, `top_das`. `uis` - сервис интересов пользователей, кроме того, что вызывается при получении анкеты пользователя, вызывается также при добавлении новых реакций (лайков, избранного и т.д.) Здесь мы рассматриваем любое получаемое событие как набор тэгов и метку о типе события. Логика сервиса такова: 1) определяем тип события: лайк - 1 отметка, избранное - 5 отметок, анкета - 50; 2) В зависимости от типа события мы изменяем вектор интересов пользователя, считая вес каждого тэга как вероятность того, что этот тэг находится в случайно выбранном "отмеченном" пользователем мероприятии; 3) сохраняем обновлённые данные и передаем событие с ними дальше по цепочке - в сервис ранжирования `ranking`. Сервис ранжирования также начинает работу при добавлении новых мероприятий в модуле погрузчике данных - тогда нужно обновить топы для всех пользователей, ведь, возможно, появились новые мероприятия. Логика сервиса заключается в том, что мы ранжируем мероприятия по степени близости их векторов к вектору интересов пользователя, полученному на предыдущем этапе. Далее отранжированный список передается в `top_das` - хранилище-обёртку над базой данных. Из этого хранилища берет информацию сервис фильтрации.

### Документация микросервисов

Мы использовали два типа обмена информацией между микросервисами: по `http` протоколу и через `rpc`, с помощью брокера сообщений `rabbitmq`. Передача по `http` предназначена для ручного тестирования или для связи с фронтом, тогда как взаимодействие сервисов между собой с помощью брокера - способ передачи данных, когда проект уже развёрнут на хосте. Далее вы можете детально ознакомиться с документацией по каждому микросервису, в т.ч. с наличествующими `http` и `rpc` методами.
